@startuml classes_AI-Boardgame
set namespaceSeparator none
class "ABC" as abc.ABC #grey {
}
class "ABCMeta" as _py_abc.ABCMeta #grey {
  register(subclass)
}
class "ABCMeta" as abc.ABCMeta #grey {
  register(subclass)
}
class "AbstractCameraInterface" as src.aiBoardGame.vision.camera.AbstractCameraInterface #aliceblue {
  calibrated : ClassVar[Event]
  calibrationMinPatternCount : ClassVar[int]
  isCalibrated
  resolution : Union[Resolution, Tuple[int, int]]
  calibrate(checkerBoardImages: List[np.ndarray], checkerBoardShape: Tuple[int, int]) -> None
  isSuitableForCalibration(image: np.ndarray, checkerBoardShape: Tuple[int, int]) -> bool
  loadParameters(filePath: Path) -> None
  saveParameters(filePath: Path) -> None
  undistort(image: np.ndarray) -> np.ndarray
}
class "Advisor" as src.aiBoardGame.logic.engine.pieces.advisor.Advisor #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
  fileBounds : ClassVar[Tuple[int, int]]
  rankBounds : ClassVar[Tuple[int, int]]
}
class "Board" as src.aiBoardGame.logic.engine.auxiliary.Board #aliceblue {
  fen
  fileBounds : ClassVar[Tuple[int, int]]
  fileCount : ClassVar[int]
  pieces
  rankBounds : ClassVar[Tuple[int, int]]
  rankCount : ClassVar[int]
  isInBounds(position: Position) -> bool
}
class "BoardEntity" as src.aiBoardGame.logic.engine.auxiliary.BoardEntity #aliceblue {
  fen
  piece : Type[Piece]
  side
}
class "BoardImage" as src.aiBoardGame.vision.boardImage.BoardImage #aliceblue {
  data : ndarray
  fileStep : int
  hsvRanges : ClassVar[Tuple[np.ndarray]]
  pieceSizeMultiplier : ClassVar[float]
  pieceThresholdDivisor : ClassVar[float]
  pieceTiles
  pieces
  positions : ndarray
  rankStep : int
  roi
  tileSize : ndarray
  tileSizeMultiplier : ClassVar[float]
  tiles
  findPiece(position: Position) -> Optional[np.ndarray]
  markDetectedPieces() -> BoardImage
  tile(position: Position) -> np.ndarray
}
class "<color:red>CameraError</color>" as src.aiBoardGame.vision.camera.CameraError #aliceblue {
  message : str
}
class "Cannon" as src.aiBoardGame.logic.engine.pieces.cannon.Cannon #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
}
class "Chariot" as src.aiBoardGame.logic.engine.pieces.chariot.Chariot #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
}
class "DataLoader" as torch.utils.data.dataloader.DataLoader #antiquewhite {
  batch_sampler : Optional[Union[Sampler[Sequence], Iterable[Sequence], None]]
  batch_size : Optional[int]
  batch_size : Optional[int]
  collate_fn : Optional[_collate_fn_t]
  dataset : Dataset[T_co]
  dataset : _MapDataPipeSerializationWrapper, Dataset[T_co], _IterDataPipeSerializationWrapper
  drop_last : bool
  drop_last : bool
  generator : NoneType
  multiprocessing_context
  multiprocessing_context : NoneType
  num_workers : int
  num_workers : int
  persistent_workers : bool
  pin_memory : bool
  pin_memory : bool
  pin_memory_device : str
  pin_memory_device : str
  prefetch_factor : int
  prefetch_factor : int
  sampler : Optional[Union[Sampler, Iterable, None]]
  sampler : Union[Sampler, Iterable]
  timeout : float
  timeout : float
  worker_init_fn : Optional[_worker_init_fn_t]
  check_worker_number_rationality()
}
class "Dataset" as torch.utils.data.dataset.Dataset #antiquewhite {
}
class "DatasetFolder" as torchvision.datasets.folder.DatasetFolder #aquamarine {
  class_to_idx
  classes
  extensions : Optional[Tuple[str, ...]]
  loader : Callable[[str], Any]
  samples : list
  targets
  find_classes(directory: str) -> Tuple[List[str], Dict[str, int]]
  make_dataset(directory: str, class_to_idx: Dict[str, int], extensions: Optional[Tuple[str, ...]], is_valid_file: Optional[Callable[[str], bool]]) -> List[Tuple[str, int]]
}
class "Delta" as src.aiBoardGame.logic.engine.auxiliary.Delta #aliceblue {
  file : Union[int, float]
  rank : Union[int, float]
  normalize() -> Delta
  round() -> Delta
}
class "Dict" as typing.Dict #grey {
}
class "Difficulty" as src.aiBoardGame.logic.stockfish.fairyStockfish.Difficulty #aliceblue {
  name
}
class "EarlyStopping" as src.aiBoardGame.vision.xiangqiPieceClassifier.earlyStopping.EarlyStopping #aliceblue {
  bestScore : NoneType
  checkpointPath : Path
  counter : int
  delta : float
  isEarlyStop : bool
  patience : int
  validationMinLoss : float
  saveCheckpoint(model: nn.Module, validationLoss: float)
}
class "Elephant" as src.aiBoardGame.logic.engine.pieces.elephant.Elephant #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
  fileBounds : ClassVar[Tuple[int, int]]
  rankBounds : ClassVar[Tuple[int, int]]
}
class "Enum" as enum.Enum #grey {
  name()
  value()
}
class "FairyStockfish" as src.aiBoardGame.logic.stockfish.fairyStockfish.FairyStockfish #aliceblue {
  baseBinaryPath : ClassVar[Path]
  currentFen
  difficulty
  go() -> str
  nextMove(fen: str) -> Optional[Tuple[Position, Position]]
  position(fen: str) -> None
}
class "FinalMeta" as src.aiBoardGame.gameplay.utility.FinalMeta #aliceblue {
}
class "FontFormat" as src.aiBoardGame.logic.engine.utility.FontFormat #aliceblue {
  BOLD : str
  ENDC : str
  FAIL : str
  HEADER : str
  OKBLUE : str
  OKCYAN : str
  OKGREEN : str
  UNDERLINE : str
  WARNING : str
}
class "<color:red>GameplayError</color>" as src.aiBoardGame.gameplay.xiangqi.GameplayError #aliceblue {
  message : str
}
class "General" as src.aiBoardGame.logic.engine.pieces.general.General #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
  fileBounds : ClassVar[Tuple[int, int]]
  rankBounds : ClassVar[Tuple[int, int]]
}
class "GenerateMode" as src.aiBoardGame.vision.xiangqiPieceClassifier.utility.GenerateMode #aliceblue {
  name
}
class "Generic" as typing.Generic #grey {
}
class "Horse" as src.aiBoardGame.logic.engine.pieces.horse.Horse #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
}
class "HumanPlayer" as src.aiBoardGame.gameplay.player.HumanPlayer #aliceblue {
  makeMoveStarted
  prepareStarted
  makeMove(fen: str) -> None
  prepare() -> None
}
class "HumanTerminalPlayer" as src.aiBoardGame.gameplay.player.HumanTerminalPlayer #aliceblue {
  isConceding : bool
  move : tuple
  makeMove(fen: str) -> None
  prepare() -> None
}
class "ImageFolder" as torchvision.datasets.folder.ImageFolder #aquamarine {
  imgs : list
}
class "IntEnum" as enum.IntEnum #grey {
}
class "<color:red>InvalidMove</color>" as src.aiBoardGame.logic.engine.move.InvalidMove #aliceblue {
  end : Position
  message : Optional[str]
  piece : Type[Piece]
  start : Position
}
class "MoveRecord" as src.aiBoardGame.logic.engine.move.MoveRecord #aliceblue {
  capturedPieceEntity : Optional[BoardEntity]
  end : Position
  movedPieceEntity : BoardEntity
  start : Position
  make(board: Board, start: Position, end: Position) -> MoveRecord
}
class "NamedTuple" as typing.NamedTuple #grey {
}
class "Piece" as aiBoardGame.logic.engine.pieces.piece.Piece #burlywood {
  abbreviations : ClassVar[Dict[str, str]]
  fileBounds : ClassVar[Tuple[int, int]]
  rankBounds : ClassVar[Tuple[int, int]]
  fileLength() -> int
  getPossibleMoves(board: Board, start: Position) -> List[Position]
  isFileInBounds(side: Side, file: int) -> bool
  isPositionInBounds(side: Side, position: Position) -> bool
  isRankInBounds(side: Side, rank: int) -> bool
  isValidMove(board: Board, side: Side, start: Position, end: Position) -> bool
  mirrorFile(file: int) -> int
  mirrorPosition(position: Position) -> Position
  mirrorRank(rank: int) -> int
  name() -> str
  rankLength() -> int
}
class "Piece" as src.aiBoardGame.logic.engine.pieces.piece.Piece #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
  fileBounds : ClassVar[Tuple[int, int]]
  rankBounds : ClassVar[Tuple[int, int]]
  fileLength() -> int
  getPossibleMoves(board: Board, start: Position) -> List[Position]
  isFileInBounds(side: Side, file: int) -> bool
  isPositionInBounds(side: Side, position: Position) -> bool
  isRankInBounds(side: Side, rank: int) -> bool
  isValidMove(board: Board, side: Side, start: Position, end: Position) -> bool
  mirrorFile(file: int) -> int
  mirrorPosition(position: Position) -> Position
  mirrorRank(rank: int) -> int
  name() -> str
  rankLength() -> int
}
class "Player" as src.aiBoardGame.gameplay.player.Player #aliceblue {
  isConceding : bool
  makeMove(fen: str) -> None
  prepare() -> None
}
class "<color:red>PlayerError</color>" as src.aiBoardGame.gameplay.player.PlayerError #aliceblue {
  message : str
}
class "Position" as src.aiBoardGame.logic.engine.auxiliary.Position #aliceblue {
  file : int
  rank : int
  isBetween(first: Position, second: Position) -> bool
}
class "Resolution" as src.aiBoardGame.vision.camera.Resolution #aliceblue {
  height : int
  width : int
}
class "RobotArm" as src.aiBoardGame.robot.robotArm.RobotArm #aliceblue {
  angle
  freeMoveHeightLimit : ClassVar[float]
  info
  isAllAttached
  isConnected
  isPumpActive
  isTouching
  polar
  position
  resetPosition : ClassVar[Tuple[float, float, float]]
  speed : int
  speed : int
  swift : SwiftAPI
  swift : SwiftAPI
  attach() -> None
  cartesianToPolar(cartesian: np.ndarray) -> np.ndarray
  connect() -> None
  detach(safe: bool) -> None
  disconnect() -> None
  isAttached(servo: Servo) -> bool
  lowerDown(speed: Optional[int]) -> None
  move(position: Tuple[float, float, Optional[float]], speed: Optional[int], safe: bool, isCartesian: bool) -> None
  moveHorizontal(stretch: float, rotation: float, speed: Optional[int]) -> None
  moveVertical(height: Optional[float], speed: Optional[int]) -> None
  polarToCartesian(polar: np.ndarray) -> np.ndarray
  reset(speed: Optional[int], safe: bool) -> None
  setAngle(servo: Servo, angle: float, speed: Optional[int]) -> None
  setPump(on: bool) -> None
}
class "<color:red>RobotArmException</color>" as src.aiBoardGame.robot.robotArm.RobotArmException #aliceblue {
  message : str
}
class "RobotArmPlayer" as src.aiBoardGame.gameplay.player.RobotArmPlayer #aliceblue {
  arm : RobotArm
  calibrateCorner
  camera : RobotCamera
  cornerCartesians : Optional[np.ndarray]
  isConceding : bool
  loadLastCalibration
  loadCalibration() -> None
  makeMove(fen: str) -> None
  prepare() -> None
}
class "RobotCamera" as src.aiBoardGame.vision.camera.RobotCamera #aliceblue {
  interval : float
  isActive : bool
  activate() -> None
  deactivate() -> None
  read(undistorted: bool) -> np.ndarray
}
class "RobotCameraInterface" as src.aiBoardGame.vision.camera.RobotCameraInterface #aliceblue {
  detectBoard(image: np.ndarray) -> BoardImage
}
class "RobotPlayer" as src.aiBoardGame.gameplay.player.RobotPlayer #aliceblue {
  difficulty
  stockfish : FairyStockfish
}
class "RobotTerminalPlayer" as src.aiBoardGame.gameplay.player.RobotTerminalPlayer #aliceblue {
  isConceding : bool
  move : tuple, NoneType
  makeMove(fen: str) -> None
  prepare() -> None
}
class "Servo" as src.aiBoardGame.robot.robotArm.Servo #aliceblue {
  name
}
class "Side" as src.aiBoardGame.logic.engine.auxiliary.Side #aliceblue {
  fen
  name
  opponent
}
class "SideState" as src.aiBoardGame.logic.engine.auxiliary.SideState #aliceblue {
}
class "Soldier" as src.aiBoardGame.logic.engine.pieces.soldier.Soldier #aliceblue {
  abbreviations : ClassVar[Dict[str, str]]
}
class "TerminalPlayer" as src.aiBoardGame.gameplay.player.TerminalPlayer #aliceblue {
  move : Optional[Tuple[Position, Position]]
}
class "TerminalXiangqi" as src.aiBoardGame.gameplay.xiangqi.TerminalXiangqi #aliceblue {
}
class "Ui_xiangqiWindow" as aiBoardGame.view.ui.xiangqiWindow.Ui_xiangqiWindow #cadetblue {
  boardFENLabel
  boardStateLayout
  calibrateButton
  calibrationCameraView
  calibrationLayout
  calibrationMethodLayout
  calibrationPage
  calibrationProgressBar
  calibrationSettingsLayout
  cameraInputComboBox
  cameraLayout
  cameraTab
  cancelCalibrationButton
  cancelLayout
  centralwidget
  checkerBoardSizeLayout
  difficultyComboBox
  difficultyLabel
  difficultyLayout
  gameCameraView
  gameLayout
  gameTab
  gridLayout
  gridLayout_2
  gridLayout_3
  gridLayout_4
  gridLayout_5
  horizontalVerticiesLabel
  horizontalVerticiesLayout
  horizontalVerticiesSpinBox
  loadCalibrationButton
  mainPage
  manualCalibrationButton
  newGameButton
  selectCameraView
  stackedWidget
  statusBar
  tabWidget
  turnLabel
  verticalVerticiesLabel
  verticalVerticiesLayout
  verticalVerticiesSpinBox
  retranslateUi(xiangqiWindow)
  setupUi(xiangqiWindow)
}
class "Utils" as src.aiBoardGame.gameplay.utility.Utils #aliceblue {
  statusUpdate
  waitEvent : Event
  waitForCorrection
  continueRun() -> None
  pauseRun() -> None
}
class "VisionDataset" as torchvision.datasets.vision.VisionDataset #aquamarine {
  root : str
  target_transform : Optional[Callable]
  transform : Optional[Callable]
  transforms : Optional[Callable]
  extra_repr() -> str
}
class "Xiangqi" as src.aiBoardGame.gameplay.xiangqi.Xiangqi #aliceblue {
  invalidMove
  invalidStartPosition
  newBoardImage
}
class "XiangqiBase" as src.aiBoardGame.gameplay.xiangqi.XiangqiBase #aliceblue {
  blackSide
  currentPlayer
  currentSide
  engineUpdated
  isOver
  over
  redSide
  sides : Dict[Side, Player]
  turn
  turn : int
  turnChanged
  winner
  play() -> None
}
class "XiangqiEngine" as src.aiBoardGame.logic.engine.xiangqiEngine.XiangqiEngine #aliceblue {
  board : Board
  currentSide : Side
  fen
  generals : Dict[Side, Position]
  isCurrentPlayerChecked
  isOver
  moveHistory : List[MoveRecord]
  winner
  move(start: Union[Position, Tuple[int, int]], end: Union[Position, Tuple[int, int]]) -> None
  newGame() -> None
  undoMove() -> None
  update(board: Board) -> None
}
class "XiangqiPieceClassifier" as src.aiBoardGame.vision.xiangqiPieceClassifier.model.XiangqiPieceClassifier #aliceblue {
  baseWeightsPath : ClassVar[Path]
  batchSize : ClassVar[int]
  classes : ClassVar[List[Optional[BoardEntity]]]
  device
  device : str
  epochCount : ClassVar[int]
  isTrained : bool
  model
  getAvailableDevice() -> Literal['cuda', 'cpu']
  loadWeights(weights: Union[Path, Dict[str, Tensor]]) -> None
  predict(inputTensor: Tensor) -> List[Optional[BoardEntity]]
  predictBoard(boardImage: BoardImage, allTiles: bool) -> Board
  predictTile(tile: np.ndarray) -> Optional[BoardEntity]
  saveWeights(savePath: Path) -> None
  test(testDataLoader: XiangqiPieceDataLoader) -> None
  trainFromScratch(trainDataLoader: XiangqiPieceDataLoader, validationDataLoader: XiangqiPieceDataLoader) -> XiangqiPieceClassifier
}
class "XiangqiPieceDataLoader" as src.aiBoardGame.vision.xiangqiPieceClassifier.dataset.XiangqiPieceDataLoader #aliceblue {
}
class "XiangqiPieceDataset" as src.aiBoardGame.vision.xiangqiPieceClassifier.dataset.XiangqiPieceDataset #aliceblue {
  basicTransform : ClassVar[transforms.Compose]
  splitSizeFractions : ClassVar[List[float]]
  trainTransform : ClassVar[transforms.Compose]
  split(root: Path, batchSize: int, numWorkers: int) -> Tuple[XiangqiPieceDataLoader, XiangqiPieceDataLoader, XiangqiPieceDataLoader]
}
class "XianqiWindow" as src.aiBoardGame.view.xiangqiWindow.XianqiWindow #aliceblue {
  blackSide : Optional[RobotArmPlayer]
  calibrationImages : List[np.ndarray]
  camera : Optional[RobotCamera], RobotCamera, NoneType
  cameraThread : Thread, Optional[Thread]
  game : Optional[Xiangqi]
  gameThread : Optional[QThread]
  loadCalibrationFileDialog
  redSide : Optional[HumanPlayer]
  robotArm : Optional[RobotArm], RobotArm
  calibrateCamera() -> None
  closeEvent(event: QCloseEvent) -> None
  collectCalibrationImage() -> None
  connectGameSignals() -> None
  connectSignals() -> None
  initCalibrationProgressBar() -> None
  initCamera(capturingDevice: str) -> None
  initCameraInputComboBox() -> None
  initDifficultyComboBox() -> None
  initGameThread() -> None
  initLoadCalibrationFileDialog() -> None
  loadCalibration(calibrationPathStr: str) -> None
  newGame() -> None
  onCalibrateCorner(corner: str) -> None
  onCalibrated() -> None
  onDifficultyChange(difficulty: str) -> None
  onGameOver() -> None
  onInvalidMove(errorMessage: str, fen: str) -> None
  onInvalidStartPosition(board: Board) -> None
  onLoadLastCalibration() -> None
  onMakeMoveStarted() -> None
  onPrepareStarted() -> None
  onWaitForCorrection(message: str) -> None
  resetCalibration() -> None
  resetCameraWidgets() -> None
  showLoadCalibrationFileDialog() -> None
  showMain() -> None
  showManualCalibration() -> None
  showSaveCalibrationFileDialog() -> None
  updateBoardFENLabel(fen: str) -> None
  updateCameraViews(cameraViews: List[QLabel]) -> None
  updateGameCameraView(boardImage: BoardImage) -> None
  updateStatusBar(status: str) -> None
  updateTurnLabel(turn: int) -> None
}
aiBoardGame.logic.engine.pieces.piece.Piece --|> abc.ABC
enum.IntEnum --|> enum.Enum
src.aiBoardGame.gameplay.player.HumanPlayer --|> src.aiBoardGame.gameplay.player.Player
src.aiBoardGame.gameplay.player.HumanTerminalPlayer --|> src.aiBoardGame.gameplay.player.TerminalPlayer
src.aiBoardGame.gameplay.player.Player --|> abc.ABC
src.aiBoardGame.gameplay.player.RobotArmPlayer --|> src.aiBoardGame.gameplay.player.RobotPlayer
src.aiBoardGame.gameplay.player.RobotPlayer --|> src.aiBoardGame.gameplay.player.Player
src.aiBoardGame.gameplay.player.RobotTerminalPlayer --|> src.aiBoardGame.gameplay.player.RobotPlayer
src.aiBoardGame.gameplay.player.RobotTerminalPlayer --|> src.aiBoardGame.gameplay.player.TerminalPlayer
src.aiBoardGame.gameplay.player.TerminalPlayer --|> src.aiBoardGame.gameplay.player.Player
src.aiBoardGame.gameplay.utility.FinalMeta --|> _py_abc.ABCMeta
src.aiBoardGame.gameplay.utility.FinalMeta --|> abc.ABCMeta
src.aiBoardGame.gameplay.xiangqi.TerminalXiangqi --|> src.aiBoardGame.gameplay.xiangqi.XiangqiBase
src.aiBoardGame.gameplay.xiangqi.Xiangqi --|> src.aiBoardGame.gameplay.xiangqi.XiangqiBase
src.aiBoardGame.gameplay.xiangqi.XiangqiBase --|> abc.ABC
src.aiBoardGame.logic.engine.auxiliary.Board --|> typing.Dict
src.aiBoardGame.logic.engine.auxiliary.BoardEntity --|> typing.NamedTuple
src.aiBoardGame.logic.engine.auxiliary.Delta --|> typing.NamedTuple
src.aiBoardGame.logic.engine.auxiliary.Position --|> typing.NamedTuple
src.aiBoardGame.logic.engine.auxiliary.Side --|> enum.IntEnum
src.aiBoardGame.logic.engine.auxiliary.SideState --|> typing.Dict
src.aiBoardGame.logic.engine.pieces.advisor.Advisor --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.cannon.Cannon --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.chariot.Chariot --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.elephant.Elephant --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.general.General --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.horse.Horse --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.engine.pieces.piece.Piece --|> abc.ABC
src.aiBoardGame.logic.engine.pieces.soldier.Soldier --|> aiBoardGame.logic.engine.pieces.piece.Piece
src.aiBoardGame.logic.stockfish.fairyStockfish.Difficulty --|> enum.Enum
src.aiBoardGame.robot.robotArm.Servo --|> enum.IntEnum
src.aiBoardGame.view.xiangqiWindow.XianqiWindow --|> aiBoardGame.view.ui.xiangqiWindow.Ui_xiangqiWindow
src.aiBoardGame.vision.camera.Resolution --|> typing.NamedTuple
src.aiBoardGame.vision.camera.RobotCamera --|> src.aiBoardGame.vision.camera.RobotCameraInterface
src.aiBoardGame.vision.camera.RobotCameraInterface --|> src.aiBoardGame.vision.camera.AbstractCameraInterface
src.aiBoardGame.vision.xiangqiPieceClassifier.dataset.XiangqiPieceDataLoader --|> torch.utils.data.dataloader.DataLoader
src.aiBoardGame.vision.xiangqiPieceClassifier.dataset.XiangqiPieceDataset --|> torchvision.datasets.folder.ImageFolder
src.aiBoardGame.vision.xiangqiPieceClassifier.utility.GenerateMode --|> enum.Enum
torch.utils.data.dataloader.DataLoader --|> typing.Generic
torch.utils.data.dataset.Dataset --|> typing.Generic
torchvision.datasets.folder.DatasetFolder --|> torchvision.datasets.vision.VisionDataset
torchvision.datasets.folder.ImageFolder --|> torchvision.datasets.folder.DatasetFolder
torchvision.datasets.vision.VisionDataset --|> torch.utils.data.dataset.Dataset
src.aiBoardGame.logic.engine.auxiliary.Side --* src.aiBoardGame.logic.engine.auxiliary.BoardEntity : side
src.aiBoardGame.logic.stockfish.fairyStockfish.Difficulty --* src.aiBoardGame.logic.stockfish.fairyStockfish.FairyStockfish : difficulty
@enduml
